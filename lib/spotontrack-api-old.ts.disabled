/**
 * SpotonTrack API Client
 * Official SpotOnTrack API implementation based on v1 API documentation
 * Provides real music industry statistics, streaming data, and market insights
 */

import { envConfig } from './env-config'

// Official SpotOnTrack API Types based on documentation
export interface SpotOnTrackSearchResult {
  name: string
  release_date: string
  artwork: string
  isrc: string
}

export interface SpotOnTrackTrackMetadata {
  name: string
  release_date: string
  artwork: string
  isrc: string
  artists: Array<{
    id: number
    name: string
    image: string
  }>
  links: {
    spotify: string[]
    apple: string[]
    deezer: string[]
    shazam: string[]
  }
}

export interface SpotOnTrackStreamData {
  date: string
  total: number
  daily: number
}

export interface SpotOnTrackPlaylist {
  position: number
  added_at: string
  playlist: {
    spotify_id?: string
    apple_id?: string
    deezer_id?: string
    name: string
    artwork: string
    followers?: number
  }
}

export interface SpotOnTrackChart {
  country_code: string
  position: number
  previous_position: number | null
  type?: string
  frequency?: string
  genre?: string
  date: string
  streams?: number
  city?: string | null
}

export interface SpotonTrackArtist {
  id: string
  name: string
  image?: string
}

export interface SpotonTrackTrack {
  isrc: string
  name: string
  artist: string
  release_date: string
  artwork: string
  artists: Array<{
    id: number
    name: string
    image: string
  }>
  links: {
    spotify: string[]
    apple: string[]
    deezer: string[]
    shazam: string[]
  }
  // Streaming data from different endpoints
  spotify_streams?: SpotOnTrackStreamData[]
  shazam_data?: Array<{
    date: string
    total: number
    daily: number | null
  }>
  // Playlist data
  spotify_playlists?: SpotOnTrackPlaylist[]
  apple_playlists?: SpotOnTrackPlaylist[]
  deezer_playlists?: SpotOnTrackPlaylist[]
  // Chart data
  spotify_charts?: SpotOnTrackChart[]
  apple_charts?: SpotOnTrackChart[]
  deezer_charts?: SpotOnTrackChart[]
  shazam_charts?: SpotOnTrackChart[]
}

class SpotonTrackAPI {
  private readonly baseUrl = 'https://www.spotontrack.com/api/v1'
  private readonly apiKey: string

  constructor() {
    this.apiKey = envConfig.spotontrackApiKey
  }




  /**
   * Check if we have a real API key configured
   */
  private hasRealApiKey(): boolean {
    return !!(this.apiKey && 
              this.apiKey !== 'dev_fallback_key' && 
              this.apiKey !== 'your_spotontrack_api_key_here' &&
              this.apiKey.length > 10);
  }

  /**
   * Make HTTP request to SpotonTrack API
   * Requires a valid API key to function
   */
  private async makeRequest(endpoint: string, params: Record<string, any> = {}): Promise<any> {
    console.log('ðŸŽ¯ SpotonTrack API request:', endpoint, params);
    
    // Require a real API key
    if (!this.hasRealApiKey()) {
      throw new Error('SpotOnTrack API key not configured or invalid. Please set SPOTONTRACK_API_KEY environment variable.');
    }
    
    try {
      // Properly construct the URL by removing leading slash from endpoint
      const cleanEndpoint = endpoint.startsWith('/') ? endpoint.slice(1) : endpoint;
      const url = new URL(cleanEndpoint, this.baseUrl + '/');
      Object.keys(params).forEach(key => {
        if (params[key] !== undefined) {
          url.searchParams.append(key, params[key]);
        }
      });

      console.log('ðŸŽ¯ Making real API call to:', url.toString());

      const response = await fetch(url.toString(), {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
      });

      if (response.ok) {
        const data = await response.json();
        console.log('ðŸŽ¯ Real API response received');
        return data;
      } else {
        const errorText = await response.text();
        console.error('ðŸŽ¯ API error:', response.status, response.statusText, errorText);
        throw new Error(`SpotOnTrack API error: ${response.status} ${response.statusText} - ${errorText}`);
      }
    } catch (error) {
      console.error('ðŸŽ¯ API request failed:', error);
      throw error;
    }
  }  /**
   * Search for tracks using official SpotOnTrack API
   * GET https://www.spotontrack.com/api/v1/tracks?query=XXXX
   */
  async searchTracks(query: string): Promise<SpotOnTrackSearchResult[]> {
    console.log(`ðŸŽ¯ SpotOnTrack: Searching tracks for: ${query}`);
    
    try {
      const response = await this.makeRequest('/tracks', { query });
      
      if (!response || !Array.isArray(response)) {
        console.log('No tracks found for query:', query);
        return [];
      }

      console.log(`âœ… Found ${response.length} tracks`);
      return response;
    } catch (error) {
      console.error('SpotonTrack track search error:', error);
      throw new Error(`Failed to search tracks: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Get track metadata using official SpotOnTrack API
   * GET https://www.spotontrack.com/api/v1/tracks/{isrc}
   */
  async getTrackMetadata(isrc: string): Promise<SpotOnTrackTrackMetadata | null> {
    console.log(`ðŸŽ¯ SpotOnTrack: Getting metadata for ISRC: ${isrc}`);
    
    try {
      const response = await this.makeRequest(`/tracks/${isrc}`);
      
      if (!response) {
        console.log('No metadata found for ISRC:', isrc);
        return null;
      }

      console.log(`âœ… Retrieved metadata for: ${response.name}`);
      return response;
    } catch (error) {
      console.error('SpotonTrack metadata error:', error);
      return null;
    }
  }

  /**
   * Get Spotify streaming data for a track
   * GET https://www.spotontrack.com/api/v1/tracks/{isrc}/spotify/streams
   */
  async getSpotifyStreams(isrc: string): Promise<SpotOnTrackStreamData[]> {
    console.log(`ðŸŽ¯ SpotOnTrack: Getting Spotify streams for: ${isrc}`);
    
    try {
      const response = await this.makeRequest(`/tracks/${isrc}/spotify/streams`);
      return response || [];
    } catch (error) {
      console.error('SpotonTrack Spotify streams error:', error);
      return [];
    }
  }

  /**
   * Get current Spotify playlists for a track
   * GET https://www.spotontrack.com/api/v1/tracks/{isrc}/spotify/playlists/current
   */
  async getSpotifyPlaylists(isrc: string): Promise<SpotOnTrackPlaylist[]> {
    console.log(`ðŸŽ¯ SpotOnTrack: Getting Spotify playlists for: ${isrc}`);
    
    try {
      const response = await this.makeRequest(`/tracks/${isrc}/spotify/playlists/current`);
      return response || [];
    } catch (error) {
      console.error('SpotonTrack Spotify playlists error:', error);
      return [];
    }
  }

  /**
   * Get current Spotify charts for a track
   * GET https://www.spotontrack.com/api/v1/tracks/{isrc}/spotify/charts/current
   */
  async getSpotifyCharts(isrc: string): Promise<SpotOnTrackChart[]> {
    console.log(`ðŸŽ¯ SpotOnTrack: Getting Spotify charts for: ${isrc}`);
    
    try {
      const response = await this.makeRequest(`/tracks/${isrc}/spotify/charts/current`);
      return response || [];
    } catch (error) {
      console.error('SpotonTrack Spotify charts error:', error);
      return [];
    }
  }

  /**
   * Get Apple Music playlists for a track
   * GET https://www.spotontrack.com/api/v1/tracks/{isrc}/apple/playlists/current
   */
  async getApplePlaylists(isrc: string): Promise<SpotOnTrackPlaylist[]> {
    console.log(`ðŸŽ¯ SpotOnTrack: Getting Apple playlists for: ${isrc}`);
    
    try {
      const response = await this.makeRequest(`/tracks/${isrc}/apple/playlists/current`);
      return response || [];
    } catch (error) {
      console.error('SpotonTrack Apple playlists error:', error);
      return [];
    }
  }

  /**
   * Get Shazam data for a track
   * GET https://www.spotontrack.com/api/v1/tracks/{isrc}/shazam/shazams
   */
  async getShazamData(isrc: string): Promise<Array<{date: string, total: number, daily: number | null}>> {
    console.log(`ðŸŽ¯ SpotOnTrack: Getting Shazam data for: ${isrc}`);
    
    try {
      const response = await this.makeRequest(`/tracks/${isrc}/shazam/shazams`);
      return response || [];
    } catch (error) {
      console.error('SpotonTrack Shazam data error:', error);
      return [];
    }
  }

  /**
   * Get comprehensive track analytics by combining multiple endpoints
   */
  async getTrackAnalytics(isrc: string): Promise<SpotonTrackTrack | null> {
    console.log(`ðŸŽ¯ SpotOnTrack: Getting comprehensive analytics for: ${isrc}`);
    
    try {
      // Get basic metadata first
      const metadata = await this.getTrackMetadata(isrc);
      if (!metadata) {
        return null;
      }

      // Get additional data in parallel
      const [
        spotifyStreams,
        spotifyPlaylists,
        spotifyCharts,
        applePlaylists,
        shazamData
      ] = await Promise.all([
        this.getSpotifyStreams(isrc),
        this.getSpotifyPlaylists(isrc),
        this.getSpotifyCharts(isrc),
        this.getApplePlaylists(isrc),
        this.getShazamData(isrc)
      ]);

      // Combine all data
      const trackAnalytics: SpotonTrackTrack = {
        isrc: metadata.isrc,
        name: metadata.name,
        artist: metadata.artists?.[0]?.name || 'Unknown',
        release_date: metadata.release_date,
        artwork: metadata.artwork,
        artists: metadata.artists,
        links: metadata.links,
        spotify_streams: spotifyStreams,
        spotify_playlists: spotifyPlaylists,
        spotify_charts: spotifyCharts,
        apple_playlists: applePlaylists,
        shazam_data: shazamData
      };

      console.log(`âœ… Comprehensive analytics compiled for: ${metadata.name}`);
      return trackAnalytics;
    } catch (error) {
      console.error('SpotonTrack analytics error:', error);
      return null;
    }
  }

  /**
   * Legacy method for backward compatibility - maps to track search
   */
  async searchArtist(query: string, limit: number = 10): Promise<SpotonTrackArtist[]> {
    console.log(`ðŸŽ¯ SpotOnTrack: Legacy artist search for: ${query}`);
    
    try {
      const tracks = await this.searchTracks(query);
      
      // Extract unique artists from track results
      const artistMap = new Map<number, SpotonTrackArtist>();
      
      for (const track of tracks.slice(0, limit)) {
        const metadata = await this.getTrackMetadata(track.isrc);
        if (metadata?.artists) {
          for (const artist of metadata.artists) {
            if (!artistMap.has(artist.id)) {
              artistMap.set(artist.id, {
                id: artist.id.toString(),
                name: artist.name,
                image: artist.image
              });
            }
          }
        }
      }

      const artists = Array.from(artistMap.values());
      console.log(`âœ… Found ${artists.length} unique artists`);
      return artists;
    } catch (error) {
  /**
   * Legacy method for backward compatibility - maps to track search by title
   */
  async searchTrack(title: string, artist?: string): Promise<SpotonTrackTrack | null> {
    console.log(`ðŸŽ¯ SpotOnTrack: Searching track: ${title}${artist ? ` by ${artist}` : ''}`);
    
    try {
      const query = artist ? `${title} ${artist}` : title;
      const tracks = await this.searchTracks(query);
      
      if (tracks.length === 0) {
        return null;
      }

      // Get detailed analytics for the first matching track
      const track = tracks[0];
      return await this.getTrackAnalytics(track.isrc);
    } catch (error) {
      console.error('SpotonTrack track search error:', error);
      return null;
    }
  }

  /**
   * Get track details by ISRC - alias for getTrackAnalytics
   */
  async getTrackDetails(isrc: string): Promise<SpotonTrackTrack | null> {
    return await this.getTrackAnalytics(isrc);
  }
        },
        playlists: {
          total: playlists ? playlists.length : 0,
          editorial: playlists ? playlists.filter((p: any) => p.playlist?.followers > 100000).length : 0,
          userGenerated: playlists ? playlists.filter((p: any) => p.playlist?.followers <= 100000).length : 0,
          spotifyPlaylists: playlists ? playlists.slice(0, 5).map((p: any) => ({
            name: p.playlist?.name || 'Unknown',
            followers: p.playlist?.followers || 0,
            url: `https://open.spotify.com/playlist/${p.playlist?.spotify_id || ''}`
          })) : []
        },
        chartPerformance: {
          peakPosition: charts && Array.isArray(charts) ? Math.min(...charts.map((c: any) => c.position)) : 0,
          currentPosition: charts && Array.isArray(charts) ? charts[0]?.position || 0 : 0,
          weeksOnChart: 0, // Not directly available
          countries: charts ? Array.from(new Set(charts.map((c: any) => c.country_code))) : []
        },
        demographics: {
          topCountries: [],
          ageGroups: [],
          gender: { male: 50, female: 50, other: 0 }
        },
        marketData: {
          popularity: 0, // Would need additional API calls
          trend: 'stable' as const,
          trendPercentage: 0,
          industry_rank: 0
        }
      };
    } catch (error) {
      console.error('Error constructing artist details:', error);
      return null;
    }
  }

    /**
   * Get artist details (constructed from track data since SpotOnTrack is track-focused)
   */
  async getArtistDetails(artistId: string): Promise<SpotonTrackArtist | null> {
    try {
      // SpotOnTrack API is track-focused, so we simulate artist data from track searches
      // In a real implementation, you might cache artist data or use additional APIs
      console.log('Note: SpotOnTrack API is track-focused. Artist details are constructed from track data.');
      
      // For now, return a basic structure
      return {
        id: artistId,
        name: `Artist ${artistId}`,
        image: undefined,
        streams: { total: 0, monthly: 0, daily: 0 },
        followers: { spotify: 0, instagram: 0, twitter: 0, facebook: 0, youtube: 0, total: 0 },
        playlists: { total: 0, editorial: 0, userGenerated: 0, spotifyPlaylists: [] },
        chartPerformance: { peakPosition: 0, currentPosition: 0, weeksOnChart: 0, countries: [] },
        demographics: { topCountries: [], ageGroups: [], gender: { male: 50, female: 50, other: 0 } },
        marketData: { popularity: 0, trend: 'stable' as const, trendPercentage: 0, industry_rank: 0 }
      };
    } catch (error) {
      console.error('Error getting SpotonTrack artist details:', error)
      return null;
    }
  }

  /**
   * Get trending artists (not available in current SpotOnTrack API)
   */
  async getTrendingArtists(timeframe: 'daily' | 'weekly' | 'monthly' = 'weekly', limit: number = 20): Promise<any[]> {
    console.log('Note: Trending artists endpoint not available in current SpotOnTrack API');
    return [];
  }

  /**
   * Get track chart history using real SpotOnTrack API
   */
  async getTrackChartHistory(isrc: string): Promise<any[]> {
    try {
      const chartData = await this.makeRequest(`/tracks/${isrc}/spotify/charts/current`);
      return Array.isArray(chartData) ? chartData : [];
    } catch (error) {
      console.error('Error getting track chart history:', error);
      return [];
    }
  }
  
  /**
   * Get Spotify streams for a track using real SpotOnTrack API
   */
  async getSpotifyStreams(isrc: string): Promise<any> {
    try {
      console.log(`Getting Spotify streams for track ISRC: ${isrc}`)
      return await this.makeRequest(`/tracks/${isrc}/spotify/streams`);
    } catch (error) {
      console.error("Get Spotify streams error:", error)
      return []
    }
  }

  /**
   * Get Spotify playlists for a track using real SpotOnTrack API
   */
  async getSpotifyPlaylists(isrc: string): Promise<any> {
    try {
      console.log(`Getting Spotify playlists for track ISRC: ${isrc}`)
      return await this.makeRequest(`/tracks/${isrc}/spotify/playlists/current`);
    } catch (error) {
      console.error("Get Spotify playlists error:", error)
      return []
    }
  }

  /**
   * Get Spotify charts for a track using real SpotOnTrack API
   */
  async getSpotifyCharts(isrc: string): Promise<any> {
    try {
      console.log(`Getting Spotify charts for track ISRC: ${isrc}`)
      return await this.makeRequest(`/tracks/${isrc}/spotify/charts/current`);
    } catch (error) {
      console.error("Get Spotify charts error:", error)
      return []
    }
  }

  /**
   * Search for tracks using real SpotOnTrack API
   */
  async searchTrack(trackTitle: string, artistName?: string): Promise<SpotonTrackTrack | null> {
    try {
      const searchQuery = artistName ? `${trackTitle} ${artistName}` : trackTitle
      const data = await this.makeRequest('/tracks', {
        query: searchQuery
      })

      if (!data || !Array.isArray(data) || data.length === 0) {
        console.log('SpotonTrack API: No tracks found for:', searchQuery);
        return null;
      }

      const track = data[0];
      return await this.getTrackDetails(track.isrc);
    } catch (error) {
      console.error('Error searching SpotonTrack track:', error)
      throw new Error(`Failed to search track: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Get detailed track information using real SpotOnTrack API
   */
  async getTrackDetails(isrc: string): Promise<SpotonTrackTrack | null> {
    try {
      const [
        basicData,
        streamingData,
        playlistData,
        chartData,
        shazamData
      ] = await Promise.allSettled([
        this.makeRequest(`/tracks/${isrc}`),
        this.makeRequest(`/tracks/${isrc}/spotify/streams`),
        this.makeRequest(`/tracks/${isrc}/spotify/playlists/current`),
        this.makeRequest(`/tracks/${isrc}/spotify/charts/current`),
        this.makeRequest(`/tracks/${isrc}/shazam/shazams`)
      ])

      const basic = basicData.status === 'fulfilled' ? basicData.value : null
      if (!basic) {
        console.log('SpotonTrack API: No track details available for ISRC:', isrc);
        return null;
      }
      
      const streaming = streamingData.status === 'fulfilled' ? streamingData.value : null
      const playlists = playlistData.status === 'fulfilled' ? playlistData.value : null
      const charts = chartData.status === 'fulfilled' ? chartData.value : null
      const shazam = shazamData.status === 'fulfilled' ? shazamData.value : null

      // Extract latest streaming data
      const latestStreams = streaming && Array.isArray(streaming) && streaming.length > 0 ? streaming[0] : null;
      
      return {
        id: basic.isrc,
        title: basic.name,
        artist: basic.artists?.[0]?.name || 'Unknown Artist',
        album: basic.album?.name,
        streams: {
          total: latestStreams?.total || 0,
          daily: latestStreams?.daily || 0,
          weekly: latestStreams?.daily ? latestStreams.daily * 7 : 0, // Approximate
          monthly: latestStreams?.daily ? latestStreams.daily * 30 : 0 // Approximate
        },
        playlists: {
          total: playlists ? playlists.length : 0,
          additions_last_week: 0, // Not directly available
          spotifyPlaylists: playlists ? playlists.slice(0, 10).map((p: any) => ({
            name: p.playlist?.name || 'Unknown',
            followers: p.playlist?.followers || 0,
            position: p.position || 0
          })) : []
        },
        charts: charts ? charts.reduce((acc: any, chart: any) => {
          if (chart.country_code === 'GLOBAL') {
            acc.spotify_global = chart.position;
          } else if (chart.country_code === 'US') {
            acc.spotify_us = chart.position;
          }
          if (!acc.peak_position || chart.position < acc.peak_position) {
            acc.peak_position = chart.position;
          }
          return acc;
        }, {}) : {},
        chartHistory: charts ? charts.map((c: any) => ({
          week: c.date,
          position: c.position
        })) : [],
        streaming_history: streaming ? streaming.slice(0, 30).map((s: any) => ({
          date: s.date,
          streams: s.daily || 0
        })) : [],
        audioFeatures: {
          danceability: 0.5, // Not available in SpotOnTrack API
          energy: 0.5,
          valence: 0.5,
          tempo: 120
        },
        marketData: {
          popularity: 0, // Would need to calculate from streams/charts
          virality_score: shazam && Array.isArray(shazam) && shazam.length > 0 ? 
            Math.min(100, (shazam[0].daily || 0) / 1000) : 0,
          commercial_appeal: charts ? Math.max(0, 100 - (charts[0]?.position || 100)) : 0
        }
      }
    } catch (error) {
      console.error('Error getting SpotonTrack track details:', error)
      return null
    }
  }

  /**
   * Check if API is working
   */
  async healthCheck(): Promise<boolean> {
    try {
      // Try a simple track search to test the API with proper URL construction
      const url = new URL('/tracks', this.baseUrl);
      url.searchParams.append('query', 'test');
      
      console.log('ðŸŽ¯ Testing API at:', url.toString());
      
      const response = await fetch(url.toString(), {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
      });

      if (response.ok) {
        const data = await response.json();
        console.log('ðŸŽ¯ SpotonTrack health check: API is working - received', Array.isArray(data) ? data.length : 'unknown', 'results');
        return true;
      } else {
        console.error('ðŸŽ¯ SpotonTrack health check failed: HTTP', response.status, response.statusText);
        return false;
      }
    } catch (error) {
      console.error('ðŸŽ¯ SpotonTrack health check failed:', error)
      return false;
    }
  }
}

export const spotontrackApi = new SpotonTrackAPI()
